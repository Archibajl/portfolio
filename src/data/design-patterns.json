[
  {
    "section": "GoF — Creational (object creation)",
    "items": [
      {
        "name": "Factory Method",
        "bestFor": [
          "Libraries",
          "Frameworks",
          "Extensible backends"
        ],
        "patternType": "Creational (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Java",
          "C#",
          "C++",
          "Kotlin",
          "Swift",
          "TypeScript",
          "Python"
        ],
        "notes": "Defer object creation to subclasses.",
        "description": "Factory Method defines an interface for creating objects, but lets subclasses (or implementers) decide which concrete type to instantiate. It’s useful when a base framework wants to allow extensions without hard-coding new types into core logic."
      },
      {
        "name": "Abstract Factory",
        "bestFor": [
          "Cross-platform SDKs",
          "UI kits",
          "Multi-vendor integrations"
        ],
        "patternType": "Creational (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "C++",
          "Kotlin",
          "Swift"
        ],
        "notes": "Create families of related objects.",
        "description": "Abstract Factory provides an interface for creating a set (family) of related objects without specifying concrete classes. It shines when you need consistent combinations (e.g., platform-specific UI components or vendor-specific integrations)."
      },
      {
        "name": "Builder",
        "bestFor": [
          "APIs with many optional params",
          "Config objects"
        ],
        "patternType": "Creational (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Java",
          "C#",
          "Kotlin",
          "Swift",
          "TypeScript"
        ],
        "notes": "Construct complex objects step-by-step.",
        "description": "Builder separates the construction of a complex object from its representation. It’s great for readable creation of objects with many optional fields and for enforcing valid construction sequences without giant constructors."
      },
      {
        "name": "Prototype",
        "bestFor": [
          "Cloning complex objects",
          "Performance-sensitive creation"
        ],
        "patternType": "Creational (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "C++",
          "Java",
          "C#",
          "Python"
        ],
        "notes": "Create by cloning an existing instance.",
        "description": "Prototype creates new objects by copying an existing instance (a prototype). It’s useful when initialization is expensive, when you want to preserve complex configuration, or when types are determined at runtime."
      },
      {
        "name": "Singleton (use sparingly)",
        "bestFor": [
          "Shared runtime services (logging/config)",
          "Embedded/system code"
        ],
        "patternType": "Creational (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Exactly one instance globally accessible.",
        "description": "Singleton ensures a class has only one instance and provides a global access point. Use carefully: it can hide dependencies, complicate tests, and increase coupling—often better replaced by dependency injection or explicit wiring."
      }
    ]
  },
  {
    "section": "GoF — Structural (composition & wiring)",
    "items": [
      {
        "name": "Adapter",
        "bestFor": [
          "Legacy integration",
          "3rd-party APIs",
          "SDKs"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Convert one interface into another.",
        "description": "Adapter wraps an existing class to make it compatible with a new interface. It’s a go-to pattern for integrating legacy code or third-party APIs without rewriting them."
      },
      {
        "name": "Facade",
        "bestFor": [
          "Simplifying complex subsystems",
          "Service clients"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "A simpler front door to a complex subsystem.",
        "description": "Facade provides a unified, simpler interface over a complicated subsystem. It reduces cognitive load and coupling by keeping callers away from internal complexity."
      },
      {
        "name": "Decorator",
        "bestFor": [
          "Middleware",
          "I/O streams",
          "HTTP pipelines"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP",
          "Functional-ish"
        ],
        "languages": [
          "Java",
          "C#",
          "Python",
          "TypeScript",
          "Kotlin"
        ],
        "notes": "Add behavior by wrapping.",
        "description": "Decorator wraps an object to add responsibilities dynamically without subclassing. Common in middleware stacks, stream pipelines, and cross-cutting behaviors like logging, retries, or caching."
      },
      {
        "name": "Composite",
        "bestFor": [
          "UI trees",
          "File systems",
          "ASTs"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Treat leaves and trees uniformly.",
        "description": "Composite composes objects into tree structures and lets clients treat individual objects and compositions uniformly. It’s ideal for hierarchical structures such as UI layouts, file directories, and syntax trees."
      },
      {
        "name": "Proxy",
        "bestFor": [
          "RPC clients",
          "Lazy loading",
          "Access control"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "Python",
          "TypeScript"
        ],
        "notes": "A stand-in that controls access.",
        "description": "Proxy provides a placeholder for another object to control access to it. Typical uses include lazy loading, remote proxies (RPC), caching, access control, and instrumentation."
      },
      {
        "name": "Bridge",
        "bestFor": [
          "Separating abstraction/implementation",
          "Platforms/drivers"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "C++",
          "Java",
          "C#"
        ],
        "notes": "Decouple abstraction from implementation.",
        "description": "Bridge splits a concept into two independently varying hierarchies: abstraction and implementation. It’s useful when you’d otherwise get a combinatorial explosion of subclasses across platforms/strategies."
      },
      {
        "name": "Flyweight",
        "bestFor": [
          "Memory optimization (glyphs/game objects)",
          "Caching"
        ],
        "patternType": "Structural (GoF)",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "C++",
          "Java",
          "C#",
          "Rust"
        ],
        "notes": "Share common state to reduce memory.",
        "description": "Flyweight reduces memory usage by sharing intrinsic (common) state across many objects and keeping extrinsic (unique) state outside. It’s common in rendering, text systems, and high-volume object scenarios."
      }
    ]
  },
  {
    "section": "GoF — Behavioral (control flow & interaction)",
    "items": [
      {
        "name": "Strategy",
        "bestFor": [
          "Pluggable algorithms (pricing/routing/ranking)"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP",
          "Functional"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Swap algorithms without changing callers.",
        "description": "Strategy defines a family of interchangeable algorithms and makes them selectable at runtime. In functional code, this often reduces to “pass a function” (higher-order functions)."
      },
      {
        "name": "Observer / Pub-Sub",
        "bestFor": [
          "UI events",
          "Reactive systems",
          "Domain events"
        ],
        "patternType": "Behavioral (GoF-ish)",
        "paradigms": [
          "OOP",
          "Reactive",
          "Functional"
        ],
        "languages": [
          "TypeScript/JS",
          "Java",
          "C#",
          "Swift",
          "Kotlin"
        ],
        "notes": "Notify subscribers when something changes.",
        "description": "Observer lets dependents subscribe to events/state changes from a subject. It’s fundamental to event emitters, reactive streams, UI event models, and domain event systems."
      },
      {
        "name": "Command",
        "bestFor": [
          "Undo/redo",
          "Job queues",
          "Handler-based apps"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP",
          "Functional"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Encapsulate a request as an object (or closure).",
        "description": "Command turns a request into a standalone object (or function) that can be queued, logged, retried, composed, or undone. It’s common in UI actions, background jobs, and command-handler architectures."
      },
      {
        "name": "State",
        "bestFor": [
          "Workflow engines",
          "UI state machines",
          "Protocol states"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP",
          "Functional"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Behavior changes as state changes.",
        "description": "State models behavior as a set of explicit states with transitions. It helps replace huge conditionals with a state machine where each state owns the logic for what happens next."
      },
      {
        "name": "Template Method",
        "bestFor": [
          "Framework hooks",
          "Consistent pipelines"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "C++"
        ],
        "notes": "Define algorithm skeleton; override steps.",
        "description": "Template Method defines the overall structure of an algorithm in a base class and lets subclasses override specific steps. It’s common in frameworks where you customize behavior via hooks."
      },
      {
        "name": "Chain of Responsibility",
        "bestFor": [
          "Web middleware",
          "Validation pipelines",
          "Logging"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP",
          "Functional"
        ],
        "languages": [
          "TypeScript/JS",
          "Java",
          "C#",
          "Python"
        ],
        "notes": "Pass a request through a chain of handlers.",
        "description": "Chain of Responsibility routes a request through a sequence of handlers until one handles it (or the chain ends). It’s the conceptual core behind middleware stacks and staged validation pipelines."
      },
      {
        "name": "Mediator",
        "bestFor": [
          "Complex UI coordination",
          "Message hubs"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "TypeScript"
        ],
        "notes": "Central coordinator reduces coupling.",
        "description": "Mediator centralizes complex communication between components so they don’t reference each other directly. It reduces tight coupling when you have many-to-many interactions (often UI-heavy systems)."
      },
      {
        "name": "Visitor",
        "bestFor": [
          "Compilers",
          "AST transforms",
          "Static analysis"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C++",
          "C#",
          "Scala"
        ],
        "notes": "Separate operations from object structure.",
        "description": "Visitor allows adding new operations over a fixed object structure without modifying the structure classes. It’s particularly useful for AST processing in compilers/analyzers, though it can be verbose."
      },
      {
        "name": "Iterator",
        "bestFor": [
          "Collection traversal abstractions"
        ],
        "patternType": "Behavioral (GoF)",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Traverse without exposing internals.",
        "description": "Iterator provides a standard way to traverse elements of a collection without exposing its underlying representation. Many modern languages bake this into the language/runtime."
      }
    ]
  },
  {
    "section": "Architectural (system-level shape)",
    "items": [
      {
        "name": "Layered (N-tier)",
        "bestFor": [
          "Enterprise backends",
          "CRUD apps"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "OOP",
          "Imperative"
        ],
        "languages": [
          "Java",
          "C#",
          "Python",
          "Ruby",
          "PHP"
        ],
        "notes": "Organize code into layers by responsibility.",
        "description": "Layered architecture splits responsibilities into layers (e.g., UI, application/service, domain, data). It’s easy to understand and common in enterprise CRUD systems, though layers can become leaky without discipline."
      },
      {
        "name": "Hexagonal (Ports & Adapters)",
        "bestFor": [
          "Testable services",
          "Clean boundaries"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any (OOP + Functional friendly)"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Domain core with adapters at the edges.",
        "description": "Hexagonal architecture keeps the domain/application core independent of external concerns by defining ports (interfaces) and adapters (implementations for DB, web, queues). This improves testability and long-term maintainability."
      },
      {
        "name": "Clean Architecture",
        "bestFor": [
          "Long-lived products",
          "Large teams"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Dependency rule: outer depends on inner.",
        "description": "Clean Architecture organizes code so high-level business rules do not depend on frameworks or delivery details. Dependencies point inward, enabling easier testing, replacement of infrastructure, and clearer separation of concerns."
      },
      {
        "name": "Microservices",
        "bestFor": [
          "Large distributed systems",
          "Org scaling"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any (Go/Java/C#/Node/Rust common)"
        ],
        "notes": "Independently deployable services.",
        "description": "Microservices split a system into independently deployable services with clear boundaries. This can improve team autonomy and scaling, but adds operational complexity (network failures, observability, deployment coordination)."
      },
      {
        "name": "Event-Driven Architecture",
        "bestFor": [
          "Streaming",
          "Async workflows",
          "Integrations"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Reactive",
          "Imperative",
          "Functional"
        ],
        "languages": [
          "Java",
          "Kotlin",
          "C#",
          "Go",
          "TypeScript/JS",
          "Scala"
        ],
        "notes": "Communicate via events for decoupling.",
        "description": "Event-driven systems communicate by publishing events that other components subscribe to. This increases decoupling and supports async workflows, but requires strong thinking around delivery guarantees, ordering, and idempotency."
      },
      {
        "name": "CQRS",
        "bestFor": [
          "Complex domains",
          "Auditability",
          "Read scaling"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Most languages"
        ],
        "notes": "Separate writes (commands) from reads (queries).",
        "description": "CQRS separates the model for writing state (commands) from reading state (queries). This can simplify complex domains and scale reads independently, but increases system complexity and introduces eventual consistency concerns."
      },
      {
        "name": "Event Sourcing",
        "bestFor": [
          "Audit trails",
          "Temporal queries"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any (often FP-friendly)"
        ],
        "languages": [
          "JVM",
          ".NET",
          "Scala",
          "Elixir"
        ],
        "notes": "Persist an append-only log of events.",
        "description": "Event Sourcing stores all changes as a sequence of events rather than storing only current state. You can reconstruct state by replaying events, enabling auditability and time-travel queries, at the cost of more complex modeling and tooling."
      },
      {
        "name": "Modular Monolith",
        "bestFor": [
          "Early-stage products",
          "Simpler ops"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "One deployable, strong internal module boundaries.",
        "description": "A modular monolith is deployed as a single unit but organized into well-defined internal modules. It often provides a great balance of simplicity and maintainability, and can be a stepping stone before microservices."
      },
      {
        "name": "SOA (Service-Oriented Architecture)",
        "bestFor": [
          "Enterprise integrations"
        ],
        "patternType": "Architectural",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Java",
          "C#",
          "Others"
        ],
        "notes": "Enterprise-style service composition.",
        "description": "SOA organizes systems as interoperable services with standardized interfaces and governance. It overlaps with microservices but is often heavier in process, shared infrastructure, and enterprise integration tooling."
      }
    ]
  },
  {
    "section": "Distributed systems & resiliency",
    "items": [
      {
        "name": "Circuit Breaker",
        "bestFor": [
          "Microservices",
          "Unreliable dependencies"
        ],
        "patternType": "Resiliency",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Java/Kotlin",
          "C#",
          "Go",
          "TypeScript/JS"
        ],
        "notes": "Fail fast when a dependency is down.",
        "description": "Circuit Breaker prevents repeated calls to a failing dependency by “opening” after a threshold of failures. This limits cascading failures and gives systems time to recover while providing predictable behavior to callers."
      },
      {
        "name": "Retry + Backoff + Jitter",
        "bestFor": [
          "Network calls",
          "Transient failures"
        ],
        "patternType": "Resiliency",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Retry intelligently to avoid overload.",
        "description": "This pattern retries transient failures using exponential backoff and random jitter. It reduces load spikes (thundering herds) and improves stability when many clients retry simultaneously."
      },
      {
        "name": "Bulkhead",
        "bestFor": [
          "Prevent cascading failures"
        ],
        "patternType": "Resiliency",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Isolate resources to contain failure.",
        "description": "Bulkhead isolates resources (e.g., separate thread pools, queues, or rate limits) so a failure in one area doesn’t sink the entire service. It’s the software equivalent of compartmentalization in ships."
      },
      {
        "name": "Rate Limiting (Token Bucket / Leaky Bucket)",
        "bestFor": [
          "Public APIs",
          "Abuse prevention"
        ],
        "patternType": "Resiliency",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Control request rate and protect systems.",
        "description": "Rate limiting restricts how many requests a caller can make over time. Token/Leaky bucket variants smooth bursts and protect downstream services from overload or abuse."
      },
      {
        "name": "Idempotency Keys",
        "bestFor": [
          "Payments",
          "Webhooks",
          "Retries"
        ],
        "patternType": "Integration",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Make repeated requests safe.",
        "description": "Idempotency keys allow clients to safely retry operations without duplicating side effects. The server deduplicates requests by key, returning the original result for repeats."
      },
      {
        "name": "Saga",
        "bestFor": [
          "Distributed transactions"
        ],
        "patternType": "Distributed workflow",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Orchestrate multi-step work with compensations.",
        "description": "Saga coordinates a sequence of local transactions across services. If a step fails, compensating actions undo prior steps. This avoids global locks in distributed systems but requires careful business-level rollback design."
      },
      {
        "name": "Outbox Pattern",
        "bestFor": [
          "Reliable event publishing with a DB"
        ],
        "patternType": "Integration",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Atomically save state + publish later.",
        "description": "Outbox writes both domain changes and outbound messages/events into the same database transaction, then publishes from the outbox asynchronously. It improves reliability and consistency across DB + message broker boundaries."
      },
      {
        "name": "Strangler Fig",
        "bestFor": [
          "Legacy modernization"
        ],
        "patternType": "Migration",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Any"
        ],
        "notes": "Replace legacy incrementally.",
        "description": "Strangler Fig gradually routes traffic from legacy functionality to new implementations until the old system can be removed. This reduces risk compared to big-bang rewrites."
      }
    ]
  },
  {
    "section": "Concurrency & async",
    "items": [
      {
        "name": "Producer–Consumer / Queue",
        "bestFor": [
          "Pipelines",
          "Ingestion",
          "Background work"
        ],
        "patternType": "Concurrency",
        "paradigms": [
          "Imperative",
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "Go",
          "Python",
          "Rust"
        ],
        "notes": "Decouple producers from consumers.",
        "description": "Producer–Consumer uses a queue to decouple work creation from work processing. It smooths spikes, enables backpressure, and helps scale processing via multiple consumers."
      },
      {
        "name": "Thread Pool / Worker Pool",
        "bestFor": [
          "Servers",
          "Batch processing"
        ],
        "patternType": "Concurrency",
        "paradigms": [
          "Imperative"
        ],
        "languages": [
          "Java",
          "C#",
          "Go",
          "Rust",
          "C++"
        ],
        "notes": "Reuse workers to process tasks.",
        "description": "Worker pools amortize thread/process creation by reusing a fixed set of workers. It improves throughput and resource control, especially in server and batch processing workloads."
      },
      {
        "name": "Futures/Promises",
        "bestFor": [
          "Async IO",
          "Web clients"
        ],
        "patternType": "Concurrency",
        "paradigms": [
          "Reactive",
          "Imperative"
        ],
        "languages": [
          "TypeScript/JS",
          "Java",
          "C#",
          "Python"
        ],
        "notes": "Represent results that complete later.",
        "description": "Futures/Promises model asynchronous results and allow composition (then/await). They simplify async control flow while still requiring attention to cancellation, timeouts, and error propagation."
      },
      {
        "name": "Actor Model",
        "bestFor": [
          "Highly concurrent services",
          "Fault isolation"
        ],
        "patternType": "Concurrency model",
        "paradigms": [
          "Reactive",
          "Functional-ish"
        ],
        "languages": [
          "Erlang",
          "Elixir",
          "Scala (Akka)",
          "JVM actors"
        ],
        "notes": "Isolate state; communicate by message.",
        "description": "Actor systems encapsulate state within actors that process one message at a time. This reduces shared-memory races and supports fault supervision, making it well-suited to high-concurrency and distributed workloads."
      },
      {
        "name": "CSP (channels)",
        "bestFor": [
          "Go-style pipelines",
          "Structured concurrency"
        ],
        "patternType": "Concurrency model",
        "paradigms": [
          "Imperative",
          "Functional-ish"
        ],
        "languages": [
          "Go",
          "Rust (tokio)",
          "Kotlin (channels)"
        ],
        "notes": "Coordinate via channels, not shared memory.",
        "description": "CSP uses communication channels to connect concurrent processes. It’s excellent for pipelines and structured concurrency, reducing the need for locks and shared mutable state."
      },
      {
        "name": "Reactor / Event Loop",
        "bestFor": [
          "Network servers",
          "UI runtimes"
        ],
        "patternType": "Concurrency",
        "paradigms": [
          "Imperative",
          "Reactive"
        ],
        "languages": [
          "Node.js",
          "Java (Netty)",
          "Python (asyncio)"
        ],
        "notes": "Dispatch async work via an event loop.",
        "description": "Reactor/Event Loop architectures use a loop to dispatch I/O events to handlers (or async tasks). This scales well for I/O-bound workloads but requires careful handling of blocking work."
      }
    ]
  },
  {
    "section": "Data access & enterprise app patterns",
    "items": [
      {
        "name": "Repository",
        "bestFor": [
          "Domain-driven backends",
          "Testability"
        ],
        "patternType": "Data access",
        "paradigms": [
          "Any"
        ],
        "languages": [
          "Java",
          "C#",
          "TypeScript",
          "Python"
        ],
        "notes": "Collection-like interface over persistence.",
        "description": "Repository abstracts data access behind domain-oriented operations (e.g., findById, save). It helps keep business logic independent of the database and makes unit testing easier by mocking repositories."
      },
      {
        "name": "Unit of Work",
        "bestFor": [
          "Transaction boundaries"
        ],
        "patternType": "Data access",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#",
          "Python"
        ],
        "notes": "Commit a group of changes as one transaction.",
        "description": "Unit of Work tracks changes to objects during a business operation and persists them in a single commit. It ensures consistency across multiple writes and is frequently implemented by ORMs behind the scenes."
      },
      {
        "name": "Active Record",
        "bestFor": [
          "Rapid CRUD apps"
        ],
        "patternType": "Data access",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Ruby (Rails)",
          "PHP (Laravel)",
          "Many ORMs"
        ],
        "notes": "Objects know how to save themselves.",
        "description": "Active Record combines domain data and persistence methods in one object. It’s fast to build with for CRUD apps but can lead to tangled domain logic in complex systems if not managed carefully."
      },
      {
        "name": "Data Mapper",
        "bestFor": [
          "Complex domains",
          "Persistence separation"
        ],
        "patternType": "Data access",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java (Hibernate)",
          "C# (EF)",
          "Python (SQLAlchemy)"
        ],
        "notes": "Keep domain model separate from persistence mapping.",
        "description": "Data Mapper keeps domain objects free of database concerns, using a separate mapping layer to translate between in-memory objects and database rows. This supports richer domain modeling and cleaner boundaries."
      },
      {
        "name": "DAO",
        "bestFor": [
          "Legacy enterprise apps"
        ],
        "patternType": "Data access",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Java",
          "C#"
        ],
        "notes": "Dedicated objects encapsulate DB queries.",
        "description": "DAO provides a dedicated class for database operations, often with method-per-query style. It’s a classic enterprise approach and still useful when you want explicit control over SQL and persistence logic."
      },
      {
        "name": "Specification",
        "bestFor": [
          "Complex query rules"
        ],
        "patternType": "Domain/data",
        "paradigms": [
          "OOP",
          "Functional-friendly"
        ],
        "languages": [
          "Java",
          "C#",
          "TypeScript"
        ],
        "notes": "Compose business rules as reusable specs.",
        "description": "Specification represents a business rule or query predicate as an object (or function) that can be combined (AND/OR/NOT). It helps keep rule logic reusable, testable, and composable."
      }
    ]
  },
  {
    "section": "UI / frontend state & presentation",
    "items": [
      {
        "name": "MVC",
        "bestFor": [
          "Server-rendered web",
          "Classic apps"
        ],
        "patternType": "UI architecture",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Many (Spring MVC, etc.)"
        ],
        "notes": "Separate Model, View, Controller.",
        "description": "MVC separates concerns: the Model holds data/business rules, the View renders the UI, and the Controller handles user input and orchestrates changes. Many web frameworks implement MVC concepts directly."
      },
      {
        "name": "MVP",
        "bestFor": [
          "Testable UI logic"
        ],
        "patternType": "UI architecture",
        "paradigms": [
          "OOP"
        ],
        "languages": [
          "Android (Java/Kotlin)",
          ".NET"
        ],
        "notes": "Presenter owns view logic; view is passive.",
        "description": "MVP emphasizes a passive View and a Presenter that contains most UI logic. It’s popular where testability is important and you want to avoid embedding logic directly in view components."
      },
      {
        "name": "MVVM",
        "bestFor": [
          "Data-binding UIs"
        ],
        "patternType": "UI architecture",
        "paradigms": [
          "OOP",
          "Reactive"
        ],
        "languages": [
          "C# (WPF)",
          "Swift",
          "Kotlin",
          "JS frameworks"
        ],
        "notes": "ViewModel exposes bindable state.",
        "description": "MVVM uses a ViewModel that exposes observable/bindable state and commands for the View. It’s strong in environments with data binding and reactive state updates, reducing glue code."
      },
      {
        "name": "Flux / Redux",
        "bestFor": [
          "Complex UI state"
        ],
        "patternType": "UI state management",
        "paradigms": [
          "Functional-ish"
        ],
        "languages": [
          "TypeScript/JavaScript"
        ],
        "notes": "Unidirectional data flow with actions/reducers.",
        "description": "Flux/Redux patterns manage state via explicit actions and pure reducers, producing predictable state transitions. This helps debug complex UI state by making changes explicit and often time-travelable."
      },
      {
        "name": "Component + Unidirectional Data Flow",
        "bestFor": [
          "Modern web UIs"
        ],
        "patternType": "UI architecture",
        "paradigms": [
          "Functional-ish"
        ],
        "languages": [
          "React (JS/TS)",
          "Elm-ish"
        ],
        "notes": "Compose UI from components; keep data flow predictable.",
        "description": "This emphasizes composable components, local state where appropriate, and predictable top-down data flow. It scales well when combined with state machines, reducers, or centralized stores for complex apps."
      }
    ]
  },
  {
    "section": "Functional / FP-native patterns",
    "items": [
      {
        "name": "Pipelines / Composition",
        "bestFor": [
          "Data processing",
          "Business rules"
        ],
        "patternType": "FP design",
        "paradigms": [
          "Functional"
        ],
        "languages": [
          "Haskell",
          "F#",
          "Scala",
          "Clojure",
          "TypeScript/JS",
          "Python"
        ],
        "notes": "Build behavior by composing small functions.",
        "description": "Function composition chains small, focused functions into larger behaviors. It improves readability and testability, especially when functions are pure and data flows in one direction through a pipeline."
      },
      {
        "name": "ADTs + Pattern Matching",
        "bestFor": [
          "Domain modeling",
          "State machines"
        ],
        "patternType": "FP design",
        "paradigms": [
          "Functional"
        ],
        "languages": [
          "Haskell",
          "OCaml",
          "F#",
          "Scala",
          "Rust",
          "Swift"
        ],
        "notes": "Model states explicitly; match exhaustively.",
        "description": "Algebraic Data Types (sum/product types) model closed sets of possibilities (e.g., states). Pattern matching forces explicit handling of cases, reducing bugs and making state machines clearer and safer."
      },
      {
        "name": "Functor / Applicative / Monad",
        "bestFor": [
          "Effects",
          "Async",
          "Optionality"
        ],
        "patternType": "FP design",
        "paradigms": [
          "Functional"
        ],
        "languages": [
          "Haskell",
          "Scala",
          "F#",
          "Rust (some)",
          "JS (libs)"
        ],
        "notes": "Abstract composition with context (maybe/async/either).",
        "description": "These abstractions describe how to map and sequence computations that carry context (like optional values, errors, async). They enable consistent composition patterns across many effect types."
      },
      {
        "name": "Lenses",
        "bestFor": [
          "Nested immutable updates"
        ],
        "patternType": "FP design",
        "paradigms": [
          "Functional"
        ],
        "languages": [
          "Haskell",
          "Scala",
          "Clojure",
          "JS (libs)"
        ],
        "notes": "Composable getters/setters for immutable structures.",
        "description": "Lenses provide a composable way to focus on and update nested data immutably. They reduce boilerplate when working with deeply nested objects while preserving immutability and clarity."
      },
      {
        "name": "Immutability + Persistent Data Structures",
        "bestFor": [
          "Concurrency-safe state"
        ],
        "patternType": "FP design",
        "paradigms": [
          "Functional"
        ],
        "languages": [
          "Clojure",
          "Scala",
          "F#",
          "JS (libs)"
        ],
        "notes": "Prefer immutable state with structural sharing.",
        "description": "Persistent data structures preserve old versions efficiently using structural sharing. Combined with immutability, they simplify reasoning about state, improve concurrency safety, and enable features like undo/history."
      }
    ]
  }
]